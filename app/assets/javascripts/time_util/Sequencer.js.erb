function Sequencer (instrument_parts) {
  var self = this;
  var running = false;
  var parts = new Arranger(instrument_parts).arrange();
  var startedrunning = 0; // TODO for testing remove me
  var tempo = 120.0;
  var oneMinute = 60.0;
  var eventsQueued = [];
  var nextEventTime = 0.0;
  var currentSubdivision = 4;  // TODO 16ths eg 4 subs per beat this is restrictive, time based is gross, options?
  var currentStepNumber = 0;
  var maxSteps = 64;
  var performanceRunning = false;
  var oneBeatTimeValue = (oneMinute / tempo);
  var schedulingLookAhead = 50.0;
  var scheduleEventHorizon = 0.1;
  var sequencerWorker = null;
  var context = window.AudioEnvironment.context;

  function advanceStep () {
    // oneBeatTimeValue = (oneMinute / tempo); // TODO refactor this out to a function that gets called on instantiation and when tempo is modified
    nextEventTime += (oneBeatTimeValue / currentSubdivision);
    currentStepNumber ++;

    if(currentStepNumber == maxSteps) {
      currentStepNumber = 0;
    }
  }

  function scheduleEvent (currentStepNumber, time ) {
    console.log(nextLoopPoint());
    self.parts.forEach(function(part) {
      var startTime = nextEventTime;

      if(eventNotAlreadyScheduled(part, startTime)){
        var endTime = nextEventTime + (oneBeatTimeValue / currentSubdivision);
        eventsQueued.push(part.generator.name() + "" + startTime.toFixed(5) );

        if (part.rhythm[currentStepNumber] == 1) {
          db("Scheduling:  " + part.generator.name() + "" + startTime.toFixed(5))
          part.generator.play(startTime, endTime);
        };
      }
    });
  }

  function eventNotAlreadyScheduled (part, startTime) {
    return !eventsQueued[part.generator.name() + "" + startTime.toFixed(5)];
  }

  function eventScheduler () {
    nextLoopPoint = nextLoopPoint();

    while (nextEventTime < context.currentTime + scheduleEventHorizon ) {
      scheduleEvent( currentStepNumber, nextEventTime );
      advanceStep();
    }
  }

  function startPerformance (parts) {
    startedrunning = context.currentTime;
    self.parts = parts;
    currentStepNumber = 0;

    nextEventTime = context.currentTime;
    sequencerWorker.postMessage('running');
  }

  function stopPerformance () {
    db("stopping");
    sequencerWorker.postMessage('stop');
  }


  function updateOneBeatValue () {
    oneBeatTimeValue = (oneMinute / tempo);
  }

  self.nextLoopPoint = function () {
    return (maxSteps - (currentStepNumber + 1)) * oneBeatTimeValue;
  }

  self.stop = function() {
   sequencerWorker.postMessage('stop');

   parts.forEach(function(p){
    p.generator.stop();
   });
   running = false;
  }

  self.run = function() {
    db("Running sequencer");
    running = true;
    performanceRunning = !performanceRunning;
    performanceRunning ? startPerformance(parts) : stopPerformance();
    updateOneBeatValue();
    //TODO should we be calling enventShecduler now prempting the worker?
  }

  self.running = function() {
    return running;
  }

  self.updateTempo = function(newTempo) {
    tempo = newTempo;
    updateOneBeatValue();
  }

  self.init = function() {
    db("Initialising sequencer");
    sequencerWorker = new Worker("<%= javascript_path "sequencerWorker.js" %>");

    sequencerWorker.onmessage = function(e) {
      if(e.data == 'step') {
        eventScheduler();
      }
      else {
        db('Received :' + e.data);
      }
    };
    sequencerWorker.postMessage({ "schedulingLookAhead": schedulingLookAhead });
  }

  self.currentClockPosition = function() {
    return self.context.currentTime;
  }

  function db(message) {
    // console.log(message);
  }
}
